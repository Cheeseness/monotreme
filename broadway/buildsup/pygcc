#!/usr/bin/env python-mpx
#-*-Python-*- Hint to [X]Emacs on colorization, etc...
#
# NOTE: This program is generated automagically by configure.  Any changes
#       you make to this POS script will be lost.
#

""" Space for rent, real cheap
"""

""" I really need to re-write this POS.
"""

import os
import sys
import getopt


def show_usage( ):
#          |--------1---------2---------3---------4---------5---------6---------7-------x-|
    print "pygcc version 1.0, January 9, 2003\n\n" \
          "Usage:\n" \
          "  pygcc [-h] [-O<option>] [-W<option>] [-o <output filespec>] <filename.py>\n" \
          "\n" \
          "Syntax:\n" \
          "  -h : Help (you're lookin' at it).\n" \
          "\n" \
          "  -i : Ignore Python compilation errors (do not return failure to caller).\n" \
          "\n" \
          "  -O : Set the \"optimization\" level, where:\n" \
          "       '-O0' disables optimization and produces a '.pyc' file (default).\n" \
          "       '-O1' enables optimization and produces a '.pyo' file.\n" \
          "       '-O2' Like 'O1' but doc-strings are also removed.\n" \
          "\n" \
          "  -W : Set the warning level, where:\n" \
          "       '-We' invokes PYChecker, stops build if PYChecker complains.\n" \
          "       '-Wi' invokes PYChecker, but does not stop build.\n" \
          "       '-Wx' do not invoke PYChecker (default).\n" \
          "\n" \
          "  -o : Specify an alternate output directory.  Ordinarily Python\n" \
          "       places bytecode in the same directory as the source.  This\n" \
          "       allows one to place compiled bytecode in a alternate dir.\n" \
          "\n" \
          "Remarks:\n" \
          "  The PYChecker option switch (-W<option>) is a placeholder for now.\n" \
          "\n" \
          "Please direct feedback and bugs to S.T. Mansfield (smansfield@envenergy.com)\n"
#          |--------1---------2---------3---------4---------5---------6---------7-------x-|

def compile_file( optimize, sourcefile, outfile, ignore_errs ):
    """Invoke a second python process to get the file 'compiled.'
       We need to invoke this as a sub-process rather than just calling
       py_compile directly so we can pass the proper optimization level
       to the python interpreter.  If we were to call py_compile here
       rather than in a sub-shell the generated bytecode might not
       have the optimization that we want...
    """
    global _buildsup_pygcc_backend

    pygccCmd = "python-mpx %s %s %s %s" % \
               (optimize, _buildsup_pygcc_backend, sourcefile, outfile)

    result = os.system( pygccCmd )
    if ignore_errs:
        return 1  # <--- Always success
    else:
        return not result


def compose_target_filespec( sourcefile_base, do_optimization, user_output_dir ):
    """Given a source filespec and optionally an output filespec (via '-o'),
       try to compose a sane output filespec based on what we're given:
        1. If user-specified output directory is empty, set the output
           directory to `cwd`.  That way if were doing a VPATH build the
           bytecode doesn't wind up in the source directory.  Stupid python.
        2. If user-specified output directory is a directory, compose an FQ
           name based on the source file and the optimization, leading to:
           DIR/FILE.py[c|o].  The directory is tested for existence/write
           accessibility.
        3. Any other condition is considered an error.
    """

    target_dir = ""
    target_name = ""
    target_ext = ""
    target_fqn = ""

# Compose the target directory name.
    if len( user_output_dir ) == 0:
        target_dir = os.getcwd( )
    else:
        target_dir = user_output_dir

    if not os.path.isdir( target_dir ):
        print "ERROR: \"" + user_output_dir + "\"\n" \
              "       refers to a non-directory filesystem object.\n"
        return ""

# Figger out the file extension based on the optimization.
    if len( do_optimization ) == 0:
        target_ext = ".pyc"
    else:
        target_ext = ".pyo"

# Duh.
    target_name = os.path.basename( sourcefile_base );

# Duh.
    target_fqn = os.path.normpath( target_dir + os.sep + target_name + target_ext )

    return target_fqn


def main( ):
    """int main( int argv, char** argc ) it ain't."""

    userOutputDir = ""
    optimizeOpt = ""
    warnOpt = ""
    doPycheck = 0
    haltOnPycheckFailure = 0
    ignoreErrors = 0;
    bytecodeFile = ""

    global _buildsup_pygcc_backend

    _buildsup_pygcc_backend = os.path.abspath(
        os.path.join(os.path.dirname(sys.argv[0]), "pygcc_backend.py")
        )
    try:
        opts, args = getopt.getopt( sys.argv[1:], 'hio:O:W:' )
    except getopt.GetoptError, e:
        print e
        print "Try 'pygcc -h' for more information."
        return 1

    for opt, arg in opts:
        if opt == '-h':
            show_usage( )
            return 1

        if opt == '-i':
            ignoreErrors = 1

        if opt == '-o':
            userOutputDir = arg

        if opt == '-O':
            if arg == '0':
                optimizeOpt = ''
            elif arg == '1':
                optimizeOpt = '-O'
            elif arg == '2':
                optimizeOpt = '-OO'
            else:
                print "Bad optimization level (" + arg + "), try 'pygcc -h' for more information."
                return 0

        if opt == '-W':
            if arg == 'e':
                doPycheck = 1
                haltOnPycheckFailure = 0
            elif arg == 'i':
                doPycheck = 1
                haltOnPycheckFailure = 1
            elif arg == 'x':
                doPycheck = 0
                haltOnPycheckFailure = 0
            else:
                print "Bad warning level (" + arg + "), try 'pygcc -h' for more information."
                return 0

# Make sure that a filename was specified.
    if len( args ) == 0:
        print "ERROR: Missing source filename."
        return 0

# Decompose the input filespec and compose a target file (.pyo/.pyc) from said spec.
    sourcefile = args[0]
    basename, baseext = sourcefile[:-3], sourcefile[-3:]

# Wouldn't make much sense to use a non-existent file now, would it?
    if not os.path.isfile( sourcefile ):
        print "ERROR: " + sourcefile + ", no such file."
        return 0

# This is really weak, but I don't know any other way to do a sanity check on the input file.
    if not baseext == '.py':
        print "ERROR: Unsupported file type ('" + baseext + "' extension unknown)."
        return 0

# TBD: PYChecker
    #if doPychecker:
    #    status = PYChecker( sourcefile )
    #    if status == <bad return value>:
    #        if haltOnPYCheckFailure:
    #            print "PYChecker warnings treated as errors, halt."
    #            return 0

    bytecodeFile = compose_target_filespec( basename, optimizeOpt, userOutputDir )
    if len( bytecodeFile ) == 0:
        return 0

    if not compile_file( optimizeOpt, sourcefile, bytecodeFile, ignoreErrors ):
        return 0

    return 1


if __name__ == '__main__':
    exit_status = not main( )
    sys.exit( exit_status )
