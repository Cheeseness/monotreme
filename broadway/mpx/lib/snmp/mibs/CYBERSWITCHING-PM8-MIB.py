"""
Copyright (C) 2010 2011 Cisco Systems

This program is free software; you can redistribute it and/or         
modify it under the terms of the GNU General Public License         
as published by the Free Software Foundation; either version 2         
of the License, or (at your option) any later version.         
    
This program is distributed in the hope that it will be useful,         
but WITHOUT ANY WARRANTY; without even the implied warranty of         
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         
GNU General Public License for more details.         
    
You should have received a copy of the GNU General Public License         
along with this program; if not, write to:         
The Free Software Foundation, Inc.         
59 Temple Place - Suite 330         
Boston, MA  02111-1307, USA.         
    
As a special exception, if other files instantiate classes, templates  
or use macros or inline functions from this project, or you compile         
this file and link it with other works to produce a work based         
on this file, this file does not by itself cause the resulting         
work to be covered by the GNU General Public License. However         
the source code for this file must still be made available in         
accordance with section (3) of the GNU General Public License.         
    
This exception does not invalidate any other reasons why a work         
based on this file might be covered by the GNU General Public         
License.
"""
# ============================================================================
# Created manually using smidump and RZ's custom version of ./libsmi2pysnmp
# Essentially::
#   $ smidump -p CYBERSWITCHING-COMMON-MIB.txt -f smiv2 \
#     CYBERSWITCHING-PM8-MIB.txt >CYBERSWITCHING-PM8-MIB.smiv2
#   $ smidump -p CYBERSWITCHING-COMMON-MIB.smiv2 \
#             -f python CYBERSWITCHING-PM8-MIB.smiv2 | \
#     ./libsmi2pysnmp >CYBERSWITCHING-PM8-MIB.py
# --------------------------------------------------------------------------
# smidump: module `CYBERSWITCHING-PM8-MIB.smiv2' contains errors, expect \
# flawed output
# ==========================================================================
# PySNMP SMI module. Autogenerated from smidump -f python CYBERSWITCHING-PM8-MIB
# by libsmi2pysnmp-0.0.7-alpha-rz2 at Thu Dec 11 00:28:12 2008,
# Python version (2, 5, 2, 'final', 0)

# Imported just in case new ASN.1 types would be created
from pyasn1.type import constraint, namedval

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols('ASN1', 'Integer', 'ObjectIdentifier', 'OctetString')
( pm8, ) = mibBuilder.importSymbols('CYBERSWITCHING-COMMON-MIB', 'pm8')
( Bits, Counter32, Counter64, Gauge32, Integer32, IpAddress, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Opaque, TimeTicks, Unsigned32, enterprises, ) = mibBuilder.importSymbols('SNMPv2-SMI', 'Bits', 'Counter32', 'Counter64', 'Gauge32', 'Integer32', 'IpAddress', 'MibIdentifier', 'NotificationType', 'MibScalar', 'MibTable', 'MibTableRow', 'MibTableColumn', 'Opaque', 'TimeTicks', 'Unsigned32', 'enterprises')
( DisplayString, ) = mibBuilder.importSymbols('SNMPv2-TC', 'DisplayString')

# Objects

pm8_ctrl = MibIdentifier((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1)).setLabel('pm8-ctrl')
numCircuits = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 1), Integer32()).setMaxAccess('readonly').setDescription('The number of managed circuits present on this system.')
circuitTable = MibTable((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2)).setDescription('A list of circuit entries.  The number of entries is given by the value of numCircuits.')
circuitEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1)).setIndexNames((0, 'CYBERSWITCHING-PM8-MIB', 'circuitIndex')).setDescription('A circuit entry containing status and properties of a circuit.')
circuitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 255))).setMaxAccess('readonly').setDescription('A unique value for each circuit.  Its value\nranges between 1 and the value of numCircuits.')
circuitLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 15))).setMaxAccess('readwrite').setDescription("A textual string containing the circuit's\nuser-friendly name.")
circuitState = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 3), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(2,3,1,4,)).subtype(namedValues=namedval.NamedValues(('off', 1), ('on', 2), ('tripped', 3), ('reboot', 4), ))).setMaxAccess('readwrite').setDescription("The circuit's state. (ON/OFF/TRIPPED/REBOOT). Reading circuitState \nreturns the circuit's state. Setting circuitState to off\nturns the circuit off. Setting circuitState to on turns the\ncircuit on. The circuit can not be set to tripped state.\nSetting circuitstate to reboot will reboot the circuit. A GET\nof circuitState returns the current state, it will never\nreturn reboot.")
circuitCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 4), DisplayString()).setMaxAccess('readonly').setDescription('The amount of current the circuit is drawing, string\nformatted.')
circuitRebootDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 5), Integer32()).setMaxAccess('readwrite').setDescription('Number of Seconds (0-6,000) before circuit reboots after a\nreboot request. This is a non-volatile setting.')
circuitRebootOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 6), Integer32()).setMaxAccess('readwrite').setDescription('Number of Seconds (0-6,000) circuit stays off before turning\nback on during a reboot. This is a non-volatile setting.')
circuitRebootDelayTimeOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 7), Integer32()).setMaxAccess('readwrite').setDescription('This is the same as oRebootDelayTime except that it is volatile\nand only applies to the next reboot of the associated circuit.\nIf frequently changing the reboot duration while a unit is\noperating, use this object instead of setting oRebootDelayTime.\nA read of this object will return the last setting until a reboot\nof the associated circuit is initiated. It will then return the\nsame value as circuitRebootDelayTime.')
circuitRebootOffTimeOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 8), Integer32()).setMaxAccess('readwrite').setDescription('This is the same as circuitRebootOffTime except that it is volatile\nand only applies to the next reboot of the associated circuit.\nIf frequently changing the reboot duration while a unit is\noperating, use this object instead of setting circuitRebootOffTime.\nA read of this object will return the last setting until a reboot\nof the associated outlet is initiated. It will then return the\nsame value as circuitRebootOffTime.')
circuitIsManaged = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 9), Integer32()).setMaxAccess('readonly').setDescription("Circuit's management status: managed circuit or unmanaged circuit.")
circuitScaleFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 10), DisplayString()).setMaxAccess('readwrite').setDescription('Circuit current scale factor (0.0-up), string formatted.')
lowCurrentAlertEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 11), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('Low current bound trap enable. When enabled, a trap will\nbe generated when current falls below lowCurrentThreshold and\nstays below for longer than lowCurrentGracePeriod.')
lowCurrentThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 12), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 20))).setMaxAccess('readwrite').setDescription('Low current threshold. This string must contain only a valid\nfloating-point number representing current in Amps between\n0.0 and 99.9. When the circuit current falls below this value,\nand stays below for longer than lowCurrentGracePeriod a trap\nwill be generated.')
lowCurrentGracePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 65535))).setMaxAccess('readwrite').setDescription('Low current grace period in Seconds. When the circuit\ncurrent falls below lowCurrentThreshold, and stays below for longer\nthan this value, a trap will be generated. Care should be\ntaken not to set this too low, or the network might be\nflooded with traps if the current rapidly fluctuates around\nlowCurrentThreshold.')
highCurrentAlertEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 14), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('High current bound trap enable. When enabled, a trap will\nbe generated when current rises above highCurrentThreshold and\nstays above for longer than highCurrentGracePeriod.')
highCurrentThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 15), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 20))).setMaxAccess('readwrite').setDescription('High current threshold. This string must contain only a valid\nfloating-point number representing current in Amps between\n0.0 and 99.9. When the circuit current rises above this value,\nand stays above for longer than highCurrentGracePeriod a trap\nwill be generated.')
highCurrentGracePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 65535))).setMaxAccess('readwrite').setDescription('High current grace period in Milliseconds. When the circuit\ncurrent rises above highCurrentThreshold, and stays above for longer\nthan this value, a trap will be generated. Care should be\ntaken not to set this too low, or the network might be\nflooded with traps if the current rapidly fluctuates around\nhighCurrentThreshold.')
vcbTripEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 17), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('High current bound Virtual Circuit Breaker(TM) enable.\nWhen enabled, the outlet will automatically shut off\nwhen current rises above highCurrentThreshold and stays above\nfor longer than highCurrentGracePeriod.')
vcbTripThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 18), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 20))).setMaxAccess('readwrite').setDescription('High current bound Virtual Circuit Breaker(TM) trip threshold. This string must contain only a valid\nfloating-point number representing current in Amps between\n0.0 and 99.9. When the circuit current rises above this value,\nand stays above for longer than vcbTripGracePeriod a trap\nwill be generated.')
vcbTripGracePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 65535))).setMaxAccess('readwrite').setDescription('High current bound Virtual Circuit Breaker(TM) trip grace period in Milliseconds. When the circuit\ncurrent rises above vcbTripThreshold, and stays above for longer\nthan this value, a trap will be generated.')
circuitEnableSchedule = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 2, 1, 20), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('Enable status of schedule.')
circuitStateMask = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 3), Integer32()).setMaxAccess('readonly').setDescription('8 bit mask representing the current state of all\n8 circuits. For each bit: 0=circuit is off,\n1=circuit is on.')
circuitPowerOnMask = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 4), Integer32()).setMaxAccess('readwrite').setDescription('8 bit mask representing power on state of all\n8 circuits. For each bit: 0=circuit is off when\nunit boots, 1=circuit is on when unit boots.')
circuitManagedMask = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 1, 5), Integer32()).setMaxAccess('readwrite').setDescription('8 bit mask representing management state of all\n8 circuits. For each bit: 0=circuit is an unmanaged \ncircuit; 1=circuit is a managed circuit.')
pm8_settings = MibIdentifier((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2)).setLabel('pm8-settings')
systemTime = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 1), Integer32()).setMaxAccess('readwrite').setDescription('Time in seconds since January 1, 1980.')
timezone = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 2), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(-13, 13))).setMaxAccess('readwrite').setDescription('Time zone as an offset from GMT')
useDaylightSavings = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 3), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('When enabled, the clock is adjusted for daylight savings.')
useNTP = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 4), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('When enabled, the unit will attempt to set its clock from the\nnetwork using NTP servers 1 & 2.')
ntpServer1 = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 5), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Time server #1. Set to 255.255.255.255 to broadcast time requests.')
ntpServer2 = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 6), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Time server #2. Will be used if Timer Server #1 fails.\nSet to 255.255.255.255 to broadcast time requests.')
useDHCP = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 7), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('When enabled, the unit will attempt to get its network settings from a DHCP\nserver upon booting. If this fails, it will revert to the manual settings.')
ipAddress = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 8), IpAddress()).setMaxAccess('readwrite').setDescription('IP of this unit.')
subnetMask = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 9), IpAddress()).setMaxAccess('readwrite').setDescription('Subnet Mask of this unit.')
gateway = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 10), IpAddress()).setMaxAccess('readwrite').setDescription('Gateway of this unit.')
dnsServer = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 11), IpAddress()).setMaxAccess('readwrite').setDescription('Domain Name Server of this unit.')
hostName = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 12), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 15))).setMaxAccess('readwrite').setDescription('Host Name of this unit.')
domain = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 13), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 32))).setMaxAccess('readwrite').setDescription('Domain of this unit.')
syslogServer = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 14), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Server name to send BSD Syslog style log events to. Set this to a\nNULL string to disable Syslog. (events will still be logged locally)')
loggingFacility = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 15), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(6,5,8,7,2,1,4,3,)).subtype(namedValues=namedval.NamedValues(('local-0', 1), ('local-1', 2), ('local-2', 3), ('local-3', 4), ('local-4', 5), ('local-5', 6), ('local-6', 7), ('local-7', 8), ))).setMaxAccess('readwrite').setDescription('BSD Syslog Logging Facility.')
loggingLevel = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 16), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(6,1,2,5,3,4,8,7,)).subtype(namedValues=namedval.NamedValues(('emergency', 1), ('alert', 2), ('critical', 3), ('error', 4), ('warning', 5), ('notice', 6), ('informational', 7), ('debug', 8), ))).setMaxAccess('readwrite').setDescription('BSD Syslog Logging Level. This affects the amount of logging performed.')
dumpLogs = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 17), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('nodump', 1), ('dump', 2), ))).setMaxAccess('readwrite').setDescription('Dump Logs to email when full option.')
smtpServer = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 18), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Server used to send email.')
emailTo = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 19), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Address to send email to.')
emailFrom = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 20), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Address to send email from.')
emailSubject = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 21), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Subject of email.')
confirmStateChanges = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 22), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('noconfirm', 1), ('confirm', 2), ))).setMaxAccess('readwrite').setDescription('Whether or not to confirm circuit changes from web\ninterface.')
httpRefreshRate = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 23), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(5, 999))).setMaxAccess('readwrite').setDescription('Number of seconds (5-999) to wait before refreshing\noutlets on web interface.')
numLogs = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 24), Integer32()).setMaxAccess('readonly').setDescription('The number of Log entries available')
logs = MibTable((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 25)).setDescription('A List of Log Entries.')
logEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 25, 1)).setIndexNames((0, 'CYBERSWITCHING-PM8-MIB', 'logIndex')).setDescription('A Log Entry Display String.')
logIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 25, 1, 1), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(1, 32))).setMaxAccess('readonly').setDescription('A unique value for each log entry. Its value\nranges between 1 and trinumlogs.')
logMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 25, 1, 2), DisplayString()).setMaxAccess('readonly').setDescription('The log entry in string form.')
serialBaudRate = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 26), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,4,3,)).subtype(namedValues=namedval.NamedValues(('baud9600', 1), ('baud19200', 2), ('baud38400', 3), ('baud57600', 4), ))).setMaxAccess('readwrite').setDescription('Serial Interface BAUD rate.')
circuitStaggerOnDelay = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 27), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 5000))).setMaxAccess('readwrite').setDescription('Number of milliseconds (0-5,000) to pause between circuits when\nturning on multiple circuits at once.')
circuitStaggerOffDelay = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 28), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 5000))).setMaxAccess('readwrite').setDescription('Number of milliseconds (0-5,000) to pause between circuits when\nturning off multiple circuits at once.')
snmpTrapServer = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 3, 2, 29), IpAddress()).setMaxAccess('readwrite').setDescription('SNMP trap server ip address.')

# Augmentions

# Notifications

circuitLowCurrentWarning = NotificationType((1, 3, 6, 1, 4, 1, 14300, 1, 3, 0, 10)).setObjects(('CYBERSWITCHING-PM8-MIB', 'circuitCurrent'), ('CYBERSWITCHING-PM8-MIB', 'circuitIndex'), )
circuitTripped = NotificationType((1, 3, 6, 1, 4, 1, 14300, 1, 3, 0, 12)).setObjects(('CYBERSWITCHING-PM8-MIB', 'circuitCurrent'), ('CYBERSWITCHING-PM8-MIB', 'circuitIndex'), )
circuitHighCurrentWarning = NotificationType((1, 3, 6, 1, 4, 1, 14300, 1, 3, 0, 11)).setObjects(('CYBERSWITCHING-PM8-MIB', 'circuitCurrent'), ('CYBERSWITCHING-PM8-MIB', 'circuitIndex'), )

# Exports

# Objects
mibBuilder.exportSymbols('CYBERSWITCHING-PM8-MIB', pm8_ctrl=pm8_ctrl, numCircuits=numCircuits, circuitTable=circuitTable, circuitEntry=circuitEntry, circuitIndex=circuitIndex, circuitLabel=circuitLabel, circuitState=circuitState, circuitCurrent=circuitCurrent, circuitRebootDelayTime=circuitRebootDelayTime, circuitRebootOffTime=circuitRebootOffTime, circuitRebootDelayTimeOverride=circuitRebootDelayTimeOverride, circuitRebootOffTimeOverride=circuitRebootOffTimeOverride, circuitIsManaged=circuitIsManaged, circuitScaleFactor=circuitScaleFactor, lowCurrentAlertEnabled=lowCurrentAlertEnabled, lowCurrentThreshold=lowCurrentThreshold, lowCurrentGracePeriod=lowCurrentGracePeriod, highCurrentAlertEnabled=highCurrentAlertEnabled, highCurrentThreshold=highCurrentThreshold, highCurrentGracePeriod=highCurrentGracePeriod, vcbTripEnabled=vcbTripEnabled, vcbTripThreshold=vcbTripThreshold, vcbTripGracePeriod=vcbTripGracePeriod, circuitEnableSchedule=circuitEnableSchedule, circuitStateMask=circuitStateMask, circuitPowerOnMask=circuitPowerOnMask, circuitManagedMask=circuitManagedMask, pm8_settings=pm8_settings, systemTime=systemTime, timezone=timezone, useDaylightSavings=useDaylightSavings, useNTP=useNTP, ntpServer1=ntpServer1, ntpServer2=ntpServer2, useDHCP=useDHCP, ipAddress=ipAddress, subnetMask=subnetMask, gateway=gateway, dnsServer=dnsServer, hostName=hostName, domain=domain, syslogServer=syslogServer, loggingFacility=loggingFacility, loggingLevel=loggingLevel, dumpLogs=dumpLogs, smtpServer=smtpServer, emailTo=emailTo, emailFrom=emailFrom, emailSubject=emailSubject, confirmStateChanges=confirmStateChanges, httpRefreshRate=httpRefreshRate, numLogs=numLogs, logs=logs, logEntry=logEntry, logIndex=logIndex, logMessage=logMessage, serialBaudRate=serialBaudRate, circuitStaggerOnDelay=circuitStaggerOnDelay, circuitStaggerOffDelay=circuitStaggerOffDelay, snmpTrapServer=snmpTrapServer)

# Notifications
mibBuilder.exportSymbols('CYBERSWITCHING-PM8-MIB', circuitLowCurrentWarning=circuitLowCurrentWarning, circuitTripped=circuitTripped, circuitHighCurrentWarning=circuitHighCurrentWarning)

