"""
Copyright (C) 2010 2011 Cisco Systems

This program is free software; you can redistribute it and/or         
modify it under the terms of the GNU General Public License         
as published by the Free Software Foundation; either version 2         
of the License, or (at your option) any later version.         
    
This program is distributed in the hope that it will be useful,         
but WITHOUT ANY WARRANTY; without even the implied warranty of         
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         
GNU General Public License for more details.         
    
You should have received a copy of the GNU General Public License         
along with this program; if not, write to:         
The Free Software Foundation, Inc.         
59 Temple Place - Suite 330         
Boston, MA  02111-1307, USA.         
    
As a special exception, if other files instantiate classes, templates  
or use macros or inline functions from this project, or you compile         
this file and link it with other works to produce a work based         
on this file, this file does not by itself cause the resulting         
work to be covered by the GNU General Public License. However         
the source code for this file must still be made available in         
accordance with section (3) of the GNU General Public License.         
    
This exception does not invalidate any other reasons why a work         
based on this file might be covered by the GNU General Public         
License.
"""
# ============================================================================
# Created manually using smidump and RZ's custom version of ./libsmi2pysnmp
# Essentially::
#   $ smidump -p CYBERSWITCHING-COMMON-MIB.txt -f smiv2 \
#     CYBERSWITCHING-DUALCOM-MIB.txt >CYBERSWITCHING-DUALCOM-MIB.smiv2
#   $ smidump -p CYBERSWITCHING-COMMON-MIB.smiv2 \
#             -f python CYBERSWITCHING-DUALCOM-MIB.smiv2 | \
#     ./libsmi2pysnmp >CYBERSWITCHING-DUALCOM-MIB.py
# --------------------------------------------------------------------------
# smidump: module `CYBERSWITCHING-DUALCOM-MIB.smiv2' contains errors, expect \
# flawed output
# ==========================================================================
# PySNMP SMI module. Autogenerated from smidump -f python CYBERSWITCHING-DUALCOM-MIB
# by libsmi2pysnmp-0.0.7-alpha-rz2 at Thu Dec 11 00:20:54 2008,
# Python version (2, 5, 2, 'final', 0)

# Imported just in case new ASN.1 types would be created
from pyasn1.type import constraint, namedval

# Imports

( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols('ASN1', 'Integer', 'ObjectIdentifier', 'OctetString')
( cyberswitching, tricomG2, ) = mibBuilder.importSymbols('CYBERSWITCHING-COMMON-MIB', 'cyberswitching', 'tricomG2')
( Bits, Counter32, Counter64, Gauge32, Integer32, IpAddress, MibIdentifier, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Opaque, TimeTicks, Unsigned32, enterprises, ) = mibBuilder.importSymbols('SNMPv2-SMI', 'Bits', 'Counter32', 'Counter64', 'Gauge32', 'Integer32', 'IpAddress', 'MibIdentifier', 'NotificationType', 'MibScalar', 'MibTable', 'MibTableRow', 'MibTableColumn', 'Opaque', 'TimeTicks', 'Unsigned32', 'enterprises')
( DisplayString, ) = mibBuilder.importSymbols('SNMPv2-TC', 'DisplayString')

# Objects

tricomG2_ctrl = MibIdentifier((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1)).setLabel('tricomG2-ctrl')
nOutlets = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 1), Integer32()).setMaxAccess('readonly').setDescription('The number of managed outlets present on this system.')
oTable = MibTable((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2)).setDescription('A list of outlet entries.  The number of\nentries is given by the value of nOutlets.')
oEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1)).setIndexNames((0, 'CYBERSWITCHING-DUALCOM-MIB', 'oIndex')).setDescription('An outlet entry containing status and properties\nof a managed outlet.')
oIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 255))).setMaxAccess('readonly').setDescription("A unique value for each outlet.  Its value\nranges between 0 and the value of nOutlets.\n0 is used to access 'All Outlets'.")
oLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 15))).setMaxAccess('readwrite').setDescription("A textual string containing the outlet's\nuser-friendly name.")
oState = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 3), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(2,3,1,4,)).subtype(namedValues=namedval.NamedValues(('off', 1), ('on', 2), ('tripped', 3), ('reboot', 4), ))).setMaxAccess('readwrite').setDescription("The outlet's state. (ON/OFF/TRIPPED). Reading oState \nreturns the outlet's state. Setting oState to off\nturns the outlet off. Setting oState to on turns the\noutlet on. The outlet can not be set to tripped state.\nSetting ostate to reboot will reboot the outlet. A GET\nof ostate returns the current state, it will never\nreturn reboot.")
oCurrentStr = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 4), DisplayString()).setMaxAccess('readonly').setDescription('The amount of current the outlet is drawing, string\nformatted.')
oCurrentInt = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 5), Integer32()).setMaxAccess('readonly').setDescription("The amount of current the outlet is drawing, in Amps\nThis is rounded to an integer for applications that can't\nhandle strings or floats.")
oRebootDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 6), Integer32()).setMaxAccess('readwrite').setDescription('Number of Seconds (0-6,000) before outlet reboots after a\nreboot request. This is a non-volatile setting.\nWriting this object for Outlet 0 (all outlets) will cause this\nvalue to be written to all outlets. Reading this object for\nOutlet 0 will always return 0.')
oRebootOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 7), Integer32()).setMaxAccess('readwrite').setDescription('Number of Seconds (0-6,000) outlet stays off before turning\nback on during a reboot. This is a non-volatile setting.\nWriting this object for Outlet 0 (all outlets) will cause this\nvalue to be written to all outlets. Reading this object for\nOutlet 0 will always return 0.')
oRebootDelayTimeOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 8), Integer32()).setMaxAccess('readwrite').setDescription('This is the same as oRebootDelayTime except that it is volatile\nand only applies to the next reboot of the associated outlet.\nIf frequently changing the reboot duration while a unit is\noperating, use this object instead of setting oRebootDelayTime.\nA read of this object will return the last setting until a reboot\nof the associated outlet is initiated. It will then return the\nsame value as oRebootDelayTime. Writing this object for Outlet 0\n(all outlets) will cause this value to be written to all outlets.\nReading this object for Outlet 0 will always return 0.')
oRebootOffTimeOverride = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 2, 1, 9), Integer32()).setMaxAccess('readwrite').setDescription('This is the same as oRebootOffTime except that it is volatile\nand only applies to the next reboot of the associated outlet.\nIf frequently changing the reboot duration while a unit is\noperating, use this object instead of setting oRebootOffTime.\nA read of this object will return the last setting until a reboot\nof the associated outlet is initiated. It will then return the\nsame value as oRebootOffTime. Writing this object for Outlet 0\n(all outlets) will cause this value to be written to all outlets.\nReading this object for Outlet 0 will always return 0.')
nBanks = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 3), Integer32()).setMaxAccess('readonly').setDescription('The number of banks (circuits) present on this system.\nAll models have at least 1 bank. Models with multiple\nfeeds or circuit breakers may have more than 1 bank.')
bTable = MibTable((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 4)).setDescription('A list of bank entries.  The number of\nentries is given by the value of nBanks.')
bEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 4, 1)).setIndexNames((0, 'CYBERSWITCHING-DUALCOM-MIB', 'bIndex')).setDescription('An bank entry containing status of a bank.')
bIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(1, 255))).setMaxAccess('readonly').setDescription('A unique value for each bank.  Its value\nranges between 1 and the value of nBanks.')
bCurrentStr = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 4, 1, 2), DisplayString()).setMaxAccess('readonly').setDescription('The amount of current the bank is drawing, string\nformatted.')
bCurrentInt = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 4, 1, 3), Integer32()).setMaxAccess('readonly').setDescription("The amount of current the bank is drawing, in Amps\nThis is rounded to an integer for applications that can't\nhandle strings or floats.")
oTotCurrentStr = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 5), DisplayString()).setMaxAccess('readonly').setDescription('The total amount of current the unit is supplying.\n(String Formatted)')
oTotCurrentInt = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 6), Integer32()).setMaxAccess('readonly').setDescription("The total amount of current the unit is supplying, in Amps.\nThis is rounded to an integer for applications that can't\nhandle strings or floats.")
oStateMask = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 7), Integer32()).setMaxAccess('readonly').setDescription('8 or 16 bit mask representing the current state of all\n8 or 16 outlets. For each bit: 0=outlet is off,\n1=outlet is on.')
oPowerOnMask = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 8), Integer32()).setMaxAccess('readwrite').setDescription('8 or 16 bit mask representing power on state of all\n8 or 16 outlets. For each bit: 0=outlet is off when\nunit boots, 1=outlet is on when unit boots.')
oInputCurL1 = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 9), DisplayString()).setMaxAccess('readonly').setDescription('The input current on the L1 wire in a\ndual-voltage model.')
oInputCurL2 = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 10), DisplayString()).setMaxAccess('readonly').setDescription('The input current on the L2 wire in a\ndual-voltage model.')
oNeutralCurrent = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 1, 11), DisplayString()).setMaxAccess('readonly').setDescription('The input current on the neutral wire in a\ndual-voltage model.')
tricomG2_mgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2)).setLabel('tricomG2-mgmt')
triSysTimeDate = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 1), Integer32()).setMaxAccess('readwrite').setDescription('Time in seconds since January 1, 1980.')
triTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(-13, 13))).setMaxAccess('readwrite').setDescription('Time zone as an offset from GMT')
triDaylightSavings = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 3), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('When enabled, the clock is adjusted for daylight savings.')
triNTPEnabled = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 4), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('When enabled, the unit will attempt to set its clock from the\nnetwork using NTP servers 1 & 2.')
triNTPServer1 = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 5), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Time server #1. Set to 255.255.255.255 to broadcast time requests.')
triNTPServer2 = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 6), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Time server #2. Will be used if Timer Server #1 fails.\nSet to 255.255.255.255 to broadcast time requests.')
triDHCPEnabled = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 7), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('When enabled, the unit will attempt to get its network settings from a DHCP\nserver upon booting. If this fails, it will revert to the manual settings.')
triNetworkIP = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 8), IpAddress()).setMaxAccess('readwrite').setDescription('IP of this unit.')
triSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 9), IpAddress()).setMaxAccess('readwrite').setDescription('Subnet Mask of this unit.')
triGateway = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 10), IpAddress()).setMaxAccess('readwrite').setDescription('Gateway of this unit.')
triDNS = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 11), IpAddress()).setMaxAccess('readwrite').setDescription('Domain Name Server of this unit.')
triHostName = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 12), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 15))).setMaxAccess('readwrite').setDescription('Host Name of this unit.')
triDomain = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 13), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 32))).setMaxAccess('readwrite').setDescription('Domain of this unit.')
triPhoneEnabled = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 14), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('Operational mode of the phone interface.\nThis object is accessible but not used on\ndualcom units.')
triBlockNoCallerID = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 15), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('noblock', 1), ('block', 2), ))).setMaxAccess('readwrite').setDescription('No CallerID blocking mode.\nThis object is accessible but not used on\ndualcom units.')
triPhonePin = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 16), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 15))).setMaxAccess('readwrite').setDescription('PIN used to access the phone interface. This must be\nat least 6 characters. This object is accessible but\nnot used on dualcom units.')
triSyslogServer = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 17), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Server name to send BSD Syslog style log events to. Set this to a\nNULL string to disable Syslog. (events will still be logged locally)')
triLoggingFacility = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 18), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(6,5,8,7,2,1,4,3,)).subtype(namedValues=namedval.NamedValues(('local-0', 1), ('local-1', 2), ('local-2', 3), ('local-3', 4), ('local-4', 5), ('local-5', 6), ('local-6', 7), ('local-7', 8), ))).setMaxAccess('readwrite').setDescription('BSD Syslog Logging Facility.')
triLoggingLevel = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 19), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(6,1,2,5,3,4,8,7,)).subtype(namedValues=namedval.NamedValues(('emergency', 1), ('alert', 2), ('critical', 3), ('error', 4), ('warning', 5), ('notice', 6), ('informational', 7), ('debug', 8), ))).setMaxAccess('readwrite').setDescription('BSD Syslog Logging Level. This affects the amount of logging performed.')
triDumpLogs = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 20), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('nodump', 1), ('dump', 2), ))).setMaxAccess('readwrite').setDescription('Dump Logs to email when full option.')
triSMTPServer = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 21), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Server used to send email.')
triEmailTo = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 22), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Address to send email to.')
triEmailFrom = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 23), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Address to send email from.')
triEmailSubject = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 24), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 59))).setMaxAccess('readwrite').setDescription('Subject of email.')
triOutletConfirmation = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 32), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('noconfirm', 1), ('confirm', 2), ))).setMaxAccess('readwrite').setDescription('Whether or not to confirm outlet changes from web\ninterface.')
triWebRefresh = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 33), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(5, 999))).setMaxAccess('readwrite').setDescription('Number of seconds (5-999) to wait before refreshing\noutlets on web interface.')
triOSchedules = MibTable((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 35)).setDescription('A List of Schedules.')
triScheduleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 35, 1)).setIndexNames((0, 'CYBERSWITCHING-DUALCOM-MIB', 'triScheduleIndex')).setDescription('An outlet schedule entry')
triScheduleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 35, 1, 1), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 255))).setMaxAccess('readonly').setDescription("A unique value for each outlet. Its value\nranges between 0 and nOutlets. Outlet '0' is\nALL Outlets.")
triScheduleEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 35, 1, 2), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('Enable status of schedule.')
trilogs = MibTable((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 38)).setDescription('A List of Log Entries.')
triLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 38, 1)).setIndexNames((0, 'CYBERSWITCHING-DUALCOM-MIB', 'triLogIndex')).setDescription('A Log Entry Display String.')
triLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 38, 1, 1), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(1, 32))).setMaxAccess('readonly').setDescription('A unique value for each log entry. Its value\nranges between 1 and trinumlogs.')
triLogString = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 38, 1, 2), DisplayString()).setMaxAccess('readonly').setDescription('The log entry in string form.')
triNumLogs = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 39), Integer32()).setMaxAccess('readonly').setDescription('The number of Log entries available')
triSerBAUD = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 40), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,4,2,3,)).subtype(namedValues=namedval.NamedValues(('baud-9600', 1), ('baud-19200', 2), ('baud-38400', 3), ('baud-57600', 4), ))).setMaxAccess('readwrite').setDescription('Serial Interface BAUD rate.')
triOutletStaggerOn = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 41), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 5000))).setMaxAccess('readwrite').setDescription('Number of milliseconds (0-5,000) to pause between outlets when\nturning on multiple outlets at once.')
triOutletStaggerOff = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 42), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 5000))).setMaxAccess('readwrite').setDescription('Number of milliseconds (0-5,000) to pause between outlets when\nturning off multiple outlets at once.')
triORebootDelayTime = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 43), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 6000))).setMaxAccess('readwrite').setDescription('Number of Seconds (0-6,000) before outlet reboots after a\nreboot request.')
triORebootOffTime = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 2, 44), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 6000))).setMaxAccess('readwrite').setDescription('Number of Seconds (0-6,000) outlet stays off before turning\nback on during a reboot.')
tricomG2_traps = MibIdentifier((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3)).setLabel('tricomG2-traps')
triOutletCurrentTraps = MibTable((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1)).setDescription('Table of current trap limits.')
triCurrentTrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1)).setIndexNames((0, 'CYBERSWITCHING-DUALCOM-MIB', 'triCurIndex')).setDescription('An outlet entry containing status and properties\nof a managed outlet.')
triCurIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 255))).setMaxAccess('readonly').setDescription("A unique value for each outlet.  Its value\nranges between 0 and the value of nOutlets.\n0 is used to access 'All Outlets'.")
triCurLoEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1, 2), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('Low current bound trap enable. When enabled, a trap will\nbe generated when current falls below triCurLoBound and\nstays below for longer than triCurLoGracePeriod.')
triCurLoBound = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 20))).setMaxAccess('readwrite').setDescription('Low current boundary. This string must contain only a valid\nfloating-point number representing current in Amps between\n0.0 and 99.9. When the outlet current falls below this value,\nand stays below for longer than triCurLoGracePeriod a trap\nwill be generated.')
triCurLoGracePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 65535))).setMaxAccess('readwrite').setDescription('Low current grace period in Seconds. When the outlet\ncurrent falls below triCurLoBound, and stays below for longer\nthan this value, a trap will be generated. Care should be\ntaken not to set this too low, or the network might be\nflooded with traps if the current rapidly fluctuates around\ntriCurLoBound.')
triCurHiEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1, 5), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('High current bound trap enable. When enabled, a trap will\nbe generated when current rises above triCurHiBound and\nstays above for longer than triCurHiGracePeriod.')
triCurHiBound = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1, 6), DisplayString().subtype(subtypeSpec=constraint.ValueSizeConstraint(0, 20))).setMaxAccess('readwrite').setDescription('High current boundary. This string must contain only a valid\nfloating-point number representing current in Amps between\n0.0 and 99.9. When the outlet current rises above this value,\nand stays above for longer than triCurHiGracePeriod a trap\nwill be generated.')
triCurHiGracePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, 65535))).setMaxAccess('readwrite').setDescription('High current grace period in Milliseconds. When the outlet\ncurrent rises above triCurHiBound, and stays above for longer\nthan this value, a trap will be generated. Care should be\ntaken not to set this too low, or the network might be\nflooded with traps if the current rapidly fluctuates around\ntriCurHiBound.')
triCircuitBreakerEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 1, 1, 8), Integer().subtype(subtypeSpec=constraint.SingleValueConstraint(1,2,)).subtype(namedValues=namedval.NamedValues(('disabled', 1), ('enabled', 2), ))).setMaxAccess('readwrite').setDescription('High current bound Virtual Circuit Breaker(TM) enable.\nWhen enabled, the outlet will automatically shut off\nwhen current rises above triCurHiBound and stays above\nfor longer than triCurHiGracePeriod. This is only available\non Plus models. Setting this property for Outlet 0\n(all outlets)is not allowed.')
triOutletTrapped = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 2), Integer32()).setMaxAccess('readonly').setDescription("The outlet that caused a trap (0-nOutlets). This trap variable\nis supplied for convenience. It should allow a management tool\nto respond to outlet-specific traps with less parsing. Outlet 0\ncorresponds to 'All Outlets'.")
triBankTrapped = MibScalar((1, 3, 6, 1, 4, 1, 14300, 1, 2, 3, 3), Integer32()).setMaxAccess('readonly').setDescription('The bank that caused a trap (1-nBanks). This trap variable\nis supplied for convenience. It should allow a management tool\nto respond to bank-specific traps with less parsing.')

# Augmentions

# Notifications

tricomG2UnitCurrentWarning = NotificationType((1, 3, 6, 1, 4, 1, 14300, 0, 11)).setObjects(('CYBERSWITCHING-DUALCOM-MIB', 'oTotCurrentInt'), ('CYBERSWITCHING-DUALCOM-MIB', 'oTotCurrentStr'), )
tricomG2OutletHighCurrentWarning = NotificationType((1, 3, 6, 1, 4, 1, 14300, 0, 15)).setObjects(('CYBERSWITCHING-DUALCOM-MIB', 'oCurrentStr'), ('CYBERSWITCHING-DUALCOM-MIB', 'oCurrentInt'), ('CYBERSWITCHING-DUALCOM-MIB', 'triOutletTrapped'), )
tricomG2OutletLowCurrentWarning = NotificationType((1, 3, 6, 1, 4, 1, 14300, 0, 14)).setObjects(('CYBERSWITCHING-DUALCOM-MIB', 'oCurrentStr'), ('CYBERSWITCHING-DUALCOM-MIB', 'oCurrentInt'), ('CYBERSWITCHING-DUALCOM-MIB', 'triOutletTrapped'), )
tricomG2OutletTripped = NotificationType((1, 3, 6, 1, 4, 1, 14300, 0, 16)).setObjects(('CYBERSWITCHING-DUALCOM-MIB', 'oCurrentStr'), ('CYBERSWITCHING-DUALCOM-MIB', 'oCurrentInt'), ('CYBERSWITCHING-DUALCOM-MIB', 'triOutletTrapped'), )
tricomG2UnitCurrentCritical = NotificationType((1, 3, 6, 1, 4, 1, 14300, 0, 10)).setObjects(('CYBERSWITCHING-DUALCOM-MIB', 'oTotCurrentInt'), ('CYBERSWITCHING-DUALCOM-MIB', 'oTotCurrentStr'), )
tricomG2BankCurrentWarning = NotificationType((1, 3, 6, 1, 4, 1, 14300, 0, 13)).setObjects(('CYBERSWITCHING-DUALCOM-MIB', 'triBankTrapped'), ('CYBERSWITCHING-DUALCOM-MIB', 'bCurrentInt'), ('CYBERSWITCHING-DUALCOM-MIB', 'bCurrentStr'), )
tricomG2BankCurrentCritical = NotificationType((1, 3, 6, 1, 4, 1, 14300, 0, 12)).setObjects(('CYBERSWITCHING-DUALCOM-MIB', 'triBankTrapped'), ('CYBERSWITCHING-DUALCOM-MIB', 'bCurrentInt'), ('CYBERSWITCHING-DUALCOM-MIB', 'bCurrentStr'), )

# Exports

# Objects
mibBuilder.exportSymbols('CYBERSWITCHING-DUALCOM-MIB', tricomG2_ctrl=tricomG2_ctrl, nOutlets=nOutlets, oTable=oTable, oEntry=oEntry, oIndex=oIndex, oLabel=oLabel, oState=oState, oCurrentStr=oCurrentStr, oCurrentInt=oCurrentInt, oRebootDelayTime=oRebootDelayTime, oRebootOffTime=oRebootOffTime, oRebootDelayTimeOverride=oRebootDelayTimeOverride, oRebootOffTimeOverride=oRebootOffTimeOverride, nBanks=nBanks, bTable=bTable, bEntry=bEntry, bIndex=bIndex, bCurrentStr=bCurrentStr, bCurrentInt=bCurrentInt, oTotCurrentStr=oTotCurrentStr, oTotCurrentInt=oTotCurrentInt, oStateMask=oStateMask, oPowerOnMask=oPowerOnMask, oInputCurL1=oInputCurL1, oInputCurL2=oInputCurL2, oNeutralCurrent=oNeutralCurrent, tricomG2_mgmt=tricomG2_mgmt, triSysTimeDate=triSysTimeDate, triTimeZone=triTimeZone, triDaylightSavings=triDaylightSavings, triNTPEnabled=triNTPEnabled, triNTPServer1=triNTPServer1, triNTPServer2=triNTPServer2, triDHCPEnabled=triDHCPEnabled, triNetworkIP=triNetworkIP, triSubnetMask=triSubnetMask, triGateway=triGateway, triDNS=triDNS, triHostName=triHostName, triDomain=triDomain, triPhoneEnabled=triPhoneEnabled, triBlockNoCallerID=triBlockNoCallerID, triPhonePin=triPhonePin, triSyslogServer=triSyslogServer, triLoggingFacility=triLoggingFacility, triLoggingLevel=triLoggingLevel, triDumpLogs=triDumpLogs, triSMTPServer=triSMTPServer, triEmailTo=triEmailTo, triEmailFrom=triEmailFrom, triEmailSubject=triEmailSubject, triOutletConfirmation=triOutletConfirmation, triWebRefresh=triWebRefresh, triOSchedules=triOSchedules, triScheduleEntry=triScheduleEntry, triScheduleIndex=triScheduleIndex, triScheduleEnabled=triScheduleEnabled, trilogs=trilogs, triLogEntry=triLogEntry, triLogIndex=triLogIndex, triLogString=triLogString, triNumLogs=triNumLogs, triSerBAUD=triSerBAUD, triOutletStaggerOn=triOutletStaggerOn, triOutletStaggerOff=triOutletStaggerOff, triORebootDelayTime=triORebootDelayTime, triORebootOffTime=triORebootOffTime, tricomG2_traps=tricomG2_traps, triOutletCurrentTraps=triOutletCurrentTraps, triCurrentTrapEntry=triCurrentTrapEntry, triCurIndex=triCurIndex, triCurLoEnabled=triCurLoEnabled, triCurLoBound=triCurLoBound, triCurLoGracePeriod=triCurLoGracePeriod, triCurHiEnabled=triCurHiEnabled, triCurHiBound=triCurHiBound, triCurHiGracePeriod=triCurHiGracePeriod, triCircuitBreakerEnabled=triCircuitBreakerEnabled, triOutletTrapped=triOutletTrapped, triBankTrapped=triBankTrapped)

# Notifications
mibBuilder.exportSymbols('CYBERSWITCHING-DUALCOM-MIB', tricomG2UnitCurrentWarning=tricomG2UnitCurrentWarning, tricomG2OutletHighCurrentWarning=tricomG2OutletHighCurrentWarning, tricomG2OutletLowCurrentWarning=tricomG2OutletLowCurrentWarning, tricomG2OutletTripped=tricomG2OutletTripped, tricomG2UnitCurrentCritical=tricomG2UnitCurrentCritical, tricomG2BankCurrentWarning=tricomG2BankCurrentWarning, tricomG2BankCurrentCritical=tricomG2BankCurrentCritical)

