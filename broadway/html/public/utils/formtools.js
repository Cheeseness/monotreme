/*
Copyright (C) 2009 2010 2011 Cisco Systems

This program is free software; you can redistribute it and/or         
modify it under the terms of the GNU General Public License         
as published by the Free Software Foundation; either version 2         
of the License, or (at your option) any later version.         
    
This program is distributed in the hope that it will be useful,         
but WITHOUT ANY WARRANTY; without even the implied warranty of         
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         
GNU General Public License for more details.         
    
You should have received a copy of the GNU General Public License         
along with this program; if not, write to:         
The Free Software Foundation, Inc.         
59 Temple Place - Suite 330         
Boston, MA  02111-1307, USA.         
    
As a special exception, if other files instantiate classes, templates  
or use macros or inline functions from this project, or you compile         
this file and link it with other works to produce a work based         
on this file, this file does not by itself cause the resulting         
work to be covered by the GNU General Public License. However         
the source code for this file must still be made available in         
accordance with section (3) of the GNU General Public License.         
    
This exception does not invalidate any other reasons why a work         
based on this file might be covered by the GNU General Public         
License.
*/
/************************************
    Methods used to catch configuration form submissions 
    generated by dynamic configurators displayed within 
    content panes of web pages.
    
    Forms handling may include any of the following behaviours: 
    replace, repopulate, or refresh.
    
    Where any of these behaviours may be applied to any of these 
    targets: node, children, parent, container, and document.
    
    Replace actions take replace the specified target with its 
    corresponding node in the response message.
    
    Repopulate leaves the target node in place, but replaces all 
    child nodes within it with those contained by its corresponding 
    element in the response.
    
    Refresh only uses the response content to verify that the request 
    was handled properly.  Once the response has been received, the 
    current document is reloaded.
    
    The following attributes are used by forms to specify 
    behaviour and handling:
    
    submitHandling: asynchronous (default), synchronous
    submitType: post, get (default is form method)
    responseHandling: load (default), reload, ignore
    targetId: specify elemnt ID to be replaced.
    targetRelation: element, content, parent, container, page, dialog
    targetType: specify element type to further qualify which parent.

    load cell -> replaces content of containing cell (tables only)
    load row -> replaces content of containing row (tables only)
    load table -> replaces content of containing table (tables only)
    load element -> replace form with loaded form
    load content -> replace form children with loaded children
    load container -> replace first container parent with loaded container
    load dialog -> loads contents of response into new dialog to display
    load parent -> loads contents of response into form's parent node
    reload * -> like load, but reloads current display ignores response
    ignore * -> does nothing.
    
    * parent type can be qualified by providing targetType providing 
      tag name of parent node to use. 

    * Note that parent of dialog is opener, 
      and container is opener's container.
************************************/
var displayed;
dojo.require("dijit.Dialog");
dojo.require("dijit.layout.AccordionPane");
dojo.require("dijit.layout.AccordionContainer");
dojo.require("utils.display");

function setup_forms(node) {
    var widget;
    if (node.domNode) {
        widget = node;
        node = widget.attr("domNode");
    } else {
        widget = dijit.getEnclosingWidget(node);
    }
    var forms = node.getElementsByTagName("form");
    forms = dojo.filter(forms, "return !dojo.hasClass(item, 'manual');");
    dojo.forEach(forms, setup_handling);
    widget.attr("forms", forms);
}

function setup_handling(form) {
    form.onsubmit = function() {
        return submit_form(form);
    };
}

function setup_dialog(dialog, synchronous) {
    var submits = dojo.query("input[type='submit']", dialog.domNode);
    var resets = dojo.query("input[type='reset']", dialog.domNode);
    dojo.forEach(submits, "item.disabled='disabled'");
    dojo.forEach(resets, "item.disabled='disabled'");
    dojo.forEach(submits, "dojo.style(item, 'display', 'none');");
    dojo.forEach(resets, "dojo.style(item, 'display', 'none');");
    var submit = new dijit.form.Button({label: "commit"});
    var close = new dijit.form.Button({label: "cancel"});
    var forms = dialog.domNode.getElementsByTagName("form");
    var responses = new Array();
    var handles = new Array();
    function submitForm() {
        dojo.style(dialog.domNode, "display", "none");
        dojo.forEach(handles, dojo.disconnect);
        return forms[0].submit();
    }
    function handleSubmit() {
        dojo.style(dialog.domNode, "display", "none");
        for (var i=0; i < forms.length; i++)
            submit_form(forms[i], handleResponse, handleError);
    }
    function handleClose() {
        dojo.forEach(handles, dojo.disconnect);
        if (dialog.openedBy && 
            dialog.openedBy.nodeName.toLowerCase() == "form") {
            var submits = dojo.query("input[type='submit']", dialog.openedBy);
            var resets = dojo.query("input[type='reset']", dialog.openedBy);
            var buttons = dojo.query("button", dialog.openedBy);
            dojo.forEach(submits, "dojo.removeAttr(item, 'disabled');");
            dojo.forEach(resets, "dojo.removeAttr(item, 'disabled');");
            dojo.forEach(buttons, "dojo.removeAttr(item, 'disabled');");
        }
        dialog.destroyRecursive();
    }
    function handleResponse(form, response, ioargs) {
        responses.push(response);
        if (responses.length == forms.length) {
            var args = {form: form, container: dialog};
            handle_response(args, response, ioargs);
            handleClose();
        }
        return response;
    }
    function handleError(form, response, ioargs) {
        console.error(form, response, ioargs);
        var res =  handleResponse(form, response, ioargs);
        setTimeout(function() {
        	utils.display.failure("Request failed", response.responseText);
        }, 500);
        return res;
    }
    if (!synchronous)
        handles.push(dojo.connect(submit, "onClick", handleSubmit));
    else
        handles.push(dojo.connect(submit, "onClick", submitForm));
    handles.push(dojo.connect(close, "onClick", handleClose));
    handles.push(dojo.connect(dialog.closeButtonNode,"onclick",handleClose));
    handles.push(dojo.connect(dialog.containerNode, 'onkeypress', function(evt) {
        key = evt.keyCode;
        if (key == dojo.keys.ESCAPE) {
            console.debug("Escape trapped !!")
            dojo.stopEvent(evt);
        }
    }));
    dialog.domNode.appendChild(close.domNode);
    dialog.domNode.appendChild(submit.domNode);
}

function popup_form(form, content, asynchronous) {
    // Unnecessary...
    asynchronous = asynchronous || false;
    content = decodeURIComponent(content);
    var dialog = new dijit.Dialog({
    	widgetsInTemplate: true
    });
    if(form.getAttribute("name"))
    	dialog.attr("title", form.getAttribute("name"));    
    dialog.attr("openedBy", form);
    dialog.attr("content", content);
    dialog.attr("class", "editDialog");
    dialog._supportingWidgets = dialog._supportingWidgets.concat(dialog.getChildren());
    setup_dialog(dialog, !asynchronous);
    dialog.startup();
    dialog.show();
    return false;
}

function submit_form(form, handleLoad, handleError) {
    var arguments = new Object();
    var inputs = form.getElementsByTagName("input");
    for (var i=0; i < inputs.length; i++) {
        var type = dojo.attr(inputs[i], "type");
        if (type == "submit" || type == "reset" || type == "button") {
            dojo.attr(inputs[i], "disabled", "disabled");
            if (type == "submit") {
                var action = dojo.attr(inputs[i], "value");
            }
        } else
            dojo.attr(inputs[i], "readonly", "readonly");
    }
    arguments.form = form;
    // This needs to be set because HTMLgen creates
    // invalid mark-up that causes errors if the request 
    // attempts to interpret the response as XML directly.
    arguments.handleAs = "text";
    arguments.load = dojo.partial(handleLoad || handle_response, form);
    arguments.error = dojo.partial(handleError || handle_error, form);
    var method = (form.getAttribute("method") || "PUT").toUpperCase();
    var xhrcommand;
    if (method == "GET")
        xhrcommand = dojo.xhrGet;
    else
        xhrcommand = dojo.xhrPost;
    xhrcommand(arguments);
    // Prevent browser navigation on form submit.
    return false;
}

function handle_response(args, response, ioargs) {
    var form = args.form || args;
    var container = args.container || dijit.getEnclosingWidget(form);
    var parsed = parse_response(response, ioargs);
    var targettype = dojo.attr(form, "targetType");
    var handling = dojo.attr(form, "targetHandling");
    if (targettype == "self") {
        var target = form;
        var targetid = dojo.attr(target, "id");
        //var source = dojo.query("[id='" + targetid + "']", parsed.XML)[0];
		// CSCtf80166
     	var source = getElementById(parsed.XML, '*', targetid);
        var content = dojo.attr(source, "innerHTML");
        dojo.attr(target, "innerHTML", content);
        setup_forms(form);
    } else if (targettype == "dialog") {
        var content;
        var dialog = new dijit.Dialog({
            widgetsInTemplate: true
        });
        dialog.attr("class", "editDialog");
        if(form.getAttribute("name"))
        	dialog.attr("title", form.getAttribute("name"));
        dialog.attr("openedBy", form);
        var values = dojo.formToObject(form);
        var section = values.section;
        //var editor = dojo.query("[id='" + section + "']", parsed.XML)[0];
		//CSCtf80166
		var editor = getElementById(parsed.XML, '*', section);
        if (!editor) {
            var editors = parsed.XML.getElementsByTagName("form");
            if (editors.length == 1)
                editor = editors[0];
            else {
                for (var i=0; i < editors.length; i++) {
                    if (dojo.attr(editors[i], "name") == section) {
                        editor = editors[i];
                        break;
                    }
                }
            }
        }
        if (editor && editor.nodeName.toLowerCase() == "div") {
            var container = new dijit.layout.AccordionContainer({});
            var forms = editor.getElementsByTagName("form");
            for (var i=0; i < forms.length; i++) {
                var formnode = forms[i].cloneNode(true);
                var formobject = dojo.formToObject(formnode);
                var submits = dojo.query("input[type='submit']", formnode);
                var resets = dojo.query("input[type='reset']", formnode);
                dojo.forEach(submits, "dojo.style(item, 'display', 'none');");
                dojo.forEach(resets, "dojo.style(item, 'display', 'none');");
                var configuration = {
                    title: formobject.title || "", 
                    content: formnode
                };
                var pane = new dijit.layout.ContentPane(configuration);
                container.addChild(pane);
            }
            dialog.resize({w: 450});
            dialog.attr("content", container);
        } else if (editor && editor.nodeName.toLowerCase() == "form") {
            dialog.attr("content", editor.cloneNode(true));
        } else
            dialog.attr("content", parsed.text);
        dialog._supportingWidgets = dialog._supportingWidgets.concat(dialog.getChildren());    
        setup_dialog(dialog);
        dialog.startup();
        dialog.show();
    } else if (container && container.attr("declaredClass") == "dijit.Dialog") {
        var dialog = container;
        handling = handling || "refresh";
        container = dijit.getEnclosingWidget(dialog.openedBy);
        if (handling == "refresh")
            container.refresh();
        else
            container.attr("content", parsed.text);
        setup_forms(container);
        if (dialog.open)
            dialog.destroy();
    } else if (dojo.hasAttr(form, "targetID")) {
        var target;
        var targetid = dojo.attr(form, "targetID");
        var targetnode = dojo.byId(targetid);
        var targetwidget = dijit.byId(targetid);
        
        if (targettype == "content") {
            var content = parsed.text;
            if (targetwidget) {
                targetwidget.attr("content", content);
                target = targetwidget;
            } else {
                dojo.attr(targetnode, "innerHTML", content);
                target = targetnode;
            }
        } else if (targettype == "refresh") {
            targetwidget.refresh();
            target = targetwidget;
        } else {
            //var source = dojo.query("[id='" + targetid + "']", parsed.XML)[0];
			// CSCtf80166
			// CSCtg03416: tr was only applicable while trigger and clear button clicks. 
			//				Now made it * so that all tags are searched.
			var source = getElementById(parsed.XML, '*', targetid);
            var content = dojo.attr(source, "innerHTML");
            dojo.attr(targetnode, "innerHTML", content);
            target = targetnode;
        }
        setup_forms(target);
    } else if(targettype == "ignore") {
        console.warn("targetType is set to IGNORE");
    } else 
        throw new Error("Unknown target identifier", form);
    return response;
}
//CSCtf80166
function getElementById(elem, tag, id) {
 	var tags = elem.getElementsByTagName(tag);
    var source;
    for(var i = 0; i < tags.length; i++) {
        if(tags[i].id == id) {
            source = tags[i];
            break;
        }
    }
    return source;
}
function handle_error(form, response, ioargs) {
    console.warn("Request failed");
    console.error("failed request", response, ioargs);
    dojo.forEach(form.getElementsByTagName("input"), 
                 "dojo.removeAttr(item, 'disabled')");
    dojo.forEach(form.getElementsByTagName("input"), 
                 "dojo.removeAttr(item, 'readonly')");
    setTimeout(function() {
    	utils.display.failure("Request failed", response.responseText);
    }, 500);
    return response;
}

function parse_response(response, ioargs) {
    // Get response object with XML, text, and document.
    var parsed = new Object();
    if (dojo.isString(response)) {
        var container = document.createElement("div");
        container.innerHTML = response;
        parsed.XML = container;
        parsed.text = response;
    } else {
        parsed.XML = response;
        parsed.text = ioargs.xhr.responseText;
    }
    return parsed;
}

function setup_content_tabs(container) {
    var tabs = container.getChildren();
    for (var i=0; i < tabs.length; i++) {
        var tab = tabs[i];
        if (dojo.attr(tab.domNode, "contentType") == "forms") {
            if (tab.connection)
                dojo.disconnect(tab.connection);
            var setup = dojo.partial(setup_forms, tab);
            tab.connection = dojo.connect(tab, "onLoad", setup);
        }
    }
}

/** creates a confirm dialog
 * @param manager - Json-RPC - manager object
 * 					HTTP	 - ID of the form used to delete entry 
 * @param rmText  - Json-RPC - Object containing details of 
 * 							  dialog title and confirmation text
 * 							  to be displayed
 * 					HTTP 	- confirmation text to be displayed
 * @param isJson  - boolean indicating if normal HTTP request is
 * 					being used or Json-RPC is being used 
 * @return - false to prevent navigation from the current page
 */
function confirmDialog(manager, rmText, isJson){
    console.log("creating Confirm dialog()");
    var form = null;
    var confirmationText;
    var dialogTitle;
    
    if (!isJson) {
        form = document.getElementById(manager);
        confirmationText = rmText;
        if (form.getAttribute("name")) 
            dialogTitle = form.getAttribute("name");
        else 
            dialogTitle = "";
    } else {
        confirmationText = rmText.confirmationText;
        dialogTitle = rmText.title;
    }
    
    var text = '<div id="message-symbol" style="padding-right:15px;">' +
               '<img src="/public/images/warning.png"/>' +
               '</div><div>' + confirmationText + '</div>';
    
    var confirm = new dijit.Dialog({
        title: dialogTitle,
        content: text,
        style: "width:300px;",
        onHide: function() {
            this.destroyRecursive();
        }
    });
    
    var submit = new dijit.form.Button({
        label: "commit",
        onClick: function(){
            console.log("confirmed");
            if (!isJson) {
                submit_form(form, handle_response, handle_error);
            } else {
                manager.deleteConfirmed(rmText);
            }
            confirm.hide();
        },
        style: "float:right;"
    });
    var close = new dijit.form.Button({
        label: "cancel",
        onClick: function(){
            console.log("cancelled");
            confirm.hide();
        },
        style: "float:right;"
    });
    
    confirm.domNode.appendChild(close.domNode);
    confirm.domNode.appendChild(submit.domNode);
    
    confirm.startup();
    confirm.show();
    
    return false;
}
